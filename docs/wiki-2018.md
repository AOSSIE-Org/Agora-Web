# Welcome to the Agora Web API Wiki.


_Frontend for [Agora](https://gitlab.com/aossie/Agora/): An Electronic Voting Library implemented in Scala_
This project is created using play framework 2.5 seeds [template](https://github.com/playframework/play-scala-seed.g8).

# Table of contents

- [Welcome to the Agora Web API Wiki.](#welcome-to-the-agora-web-api-wiki)
- [Table of contents](#table-of-contents)
- [Introduction](#introduction)
- [Environment variables](#environment-variables)
- [Authentication](#authentication)
- [Database](#database)
- [Email Client](#email-client)
- [Vote Counting Algorithms](#vote-counting-algorithms)
- [API Documentation](#api-documentation)
- [Demo](#demo)
- [Frontend](#frontend)

To know how to run the Project, please see [README.md](https://gitlab.com/icemc/Agora-Web/blob/master/README.md) file on the repository.


# Introduction

The scope of the project is to implement a REST API for Agora web using the [Agora](https://gitlab.com/aossie/Agora) project as vote counting library, where the Agora frontend app can make REST calls to create, schedule, edit and delete election and obtaining the elections results in due time.

# Environment variables

Before Starting to work with the project You need to configure the environment variables
for the Project. Here, environment variables are described:

|  Variable 	|  Mandatory 	|   Description
|     ---	|      ---	|       ---
|  APPLICATION_SECRET | Yes |   Secret key for play application	   	
|  MONGODB_URI        | Yes |   `mongodb://` URI of the MongoDB database
|  SENDGRID_USERNAME  | Yes | Username [Sendgrid](https://sendgrid.com/) account used to send mails in name of the system.  	   	
|  SENDGRID_PASSWORD  | In Production mode | Plain text password of sendgrid account.  	   	
|  COOKIE_SECRET_KEY  | In Production mode | Secret key to sing cookies generated by Silhouette. 	   	
|  COOKIE_ENCRYPT_KEY | In Production mode | Secret key to encrypt cookies generated by Silhouette.
|  OAUTH1_COOKIE_SECRET_KEY | In Production mode |  Secret key to sign cookies from the Oauth1.
|  OAUTH1_COOKIE_ENCRYPT_KEY | In Production mode |  Secret key to encrypt cookies from the Oauth1.   	   	
|  OAUTH2_COOKIE_SECRET_KEY | In Production mode | Secret key to encrypt cookies from the Oauth2.  	   	
|  FACEBOOK_CLIENT_ID | To use Facebook authentication    | Facebook client ID is used to identify the application   	   	
|  FACEBOOK_CLIENT_SECRET| To use Facebook authentication | Facebook Client Secret is used to authenticate the identity of the application.  	
|  GOOGLE_CLIENT_ID | To use Google authentication   |   Google client ID is used to identify the application   	   		   	
|  GOOGLE_CLIENT_SECRET	 | To use Google authentication |  Google Client Secret is used to authenticate the identity of the application.    	

For more info please check these links,

1. [Facebook](https://developers.facebook.com/)
2. [Google](https://console.cloud.google.com)


# Authentication

We have used Silhouette for the `Authentication` purpose.

> Silhouette is an authentication library for Play Framework applications that supports several authentication methods, including OAuth1, OAuth2, OpenID, CAS, Credentials, Basic Authentication or custom authentication schemes.

We used [Oauth2](https://oauth.net/2/) framework to get the details from the service providers(social providers) and Credentials for email based account. 
For OAuth2 authentication, the frontend sends a user token from the required social provider with the social providers name. The with this data silhouette tries to get the users profile from the social provide. Note that for this o work the Social providers API setting must be the same at the frontend and the backend. If the users profile was obtained a token is sent to the frontend which can be used to access restricted resources.
For email based account users signup using their email and providing the required information such as user name, email, password etc, this data is then sent to the backend in order to create the users profile, if successful an email is sent to the user with a link to confirm their account. When user clicks on the link and it is successful a token is sent to the frontend which can be used to access restricted resources.


*Get from Google Developer page*

For more details please check these links,

1. [Silhouette](https://www.silhouette.rocks/)
2. [Token Based Authentication](https://auth0.com/learn/token-based-authentication-made-easy/)

# Database

We have used MongoDB as the persistent storage for our project. We  chose MongoDB for following reasons,
1. High Write Load
2. High Availability in an Unreliable Environment (Cloud storage)
3. Data Set is Going to be Big (Election Data can go up to 1Gb)  
4. In our case Election Schema is Not Stable.

We use [Play2-ReactiveMongoDB](http://reactivemongo.org/releases/0.1x/documentation/tutorial/play.html) to connect the MongoDB, we used ReactiveMongo with JSON collections.

> `Play2-ReactiveMongoDB` is a Scala toolkit for MongoDB.

 We created an Object called MongoDBConnection to Connect with the Database. We control different database connection using the object.
Example Code,
 ```
 class ElectionDAOImpl @Inject()(val reactiveMongoApi: ReactiveMongoApi)(implicit ex: ExecutionContext) extends ElectionService {
  /**
    * The data store for the elections.
    */
  private def electionsCollection = reactiveMongoApi.database.map(_.collection[JSONCollection]("election"))

  /**
    * Saves an Election.
    *
    * @return The saved Election.
    */
  override def save(election: Election): Future[Election] = {
    electionsCollection.flatMap(_.insert(election)).flatMap {
      _ => Future.successful(election)
    }
  }
 }
 ```

See [Environment variables](#environment-variables) Section to learn about `mongoUri`.

For more details please check these links,
* [Play2-ReactiveMongoDB](http://reactivemongo.org/releases/0.1x/documentation/tutorial/play.html)

For JSON serialization we used the built-in play JSON library _play.api.libs.json_

# Email Client

We used play mailer module to build and send email messages. For our app We want those functionalities in following use cases.
1. Sending invitation and verification code for voter.
2. Sending admin link to guest users while creating the election

Configure the play mailer in `application.conf`.
 ```
    play.mailer {
      host = "example.com" // (mandatory)
      port = 25 // (defaults to 25)
      ssl = no // (defaults to no)
      tls = no // (defaults to no)
      tlsRequired = no // (defaults to no)
      user = null // (optional)
      password = null // (optional)
      debug = no // (defaults to no, to take effect you also need to set the log level to "DEBUG" for the application logger)
      timeout = null // (defaults to 60s in milliseconds)
      connectiontimeout = null // (defaults to 60s in milliseconds)
      mock = no // (defaults to no, will only log all the email properties instead of sending an email)
    }
 ```
 Check the [Environment variables](#environment-variables) Section to learn more.

 Example Code for sending mail,
```
    val email = Email(
          "Simple email",
          "Mister FROM <from@email.com>",
          Seq("Miss TO <to@email.com>"),
          // adds attachment
          attachments = Seq(
            AttachmentFile("attachment.pdf", new File("/some/path/attachment.pdf")),
            // adds inline attachment from byte array
            AttachmentData("data.txt", "data".getBytes, "text/plain", Some("Simple data"), Some(EmailAttachment.INLINE)),
            // adds cid attachment
            AttachmentFile("image.jpg", new File("/some/path/image.jpg"), contentId = Some(cid))
          ),
          // sends text, HTML or both...
          bodyText = Some("A text message"),
          bodyHtml = Some(s"""<html><body><p>An <b>html</b> message with cid <img src="cid:$cid"></p></body></html>""")
        )
```

Example codes are taken from [Play-Mailer](https://github.com/playframework/play-mailer) examples.

Select any Email Delivery Service to get the user, password for configuration. We are using Sendgrid for this purpose.

For more details please check these links,
1. [Paly-Mailer](https://github.com/playframework/play-mailer)
2. [Sendgrid](https://sendgrid.com/)

# Vote Counting Algorithms

We are using the algorithms from the [Agora](https://gitlab.com/aossie/Agora) Library. In project `models.services.Countvotes` object provide the functions for counting votes for the election. To add a new Algorithm into the system  please do the following:
1. Check is the Ballot type of this algorithm! We have support for PreferentialBallot, ScoreBallot and RankBallot. If the ballot type is not amongst those you will have to create a new parser function for the ballot type that takes a ballot input as string and creates a Ballot of that type. To see how with achieved this with the other ballot types have a look at the following
    ```
     def parseScoreBallot(ballot: Ballot): List[(Candidate, Rational)] = {
            //Expecting ballots of type (A:20/100)(B:50/100)(C:2/100)
            val candidatesList = ListBuffer[(Candidate, Rational)]()
            val ballotToList = ballot.voteBallot.split("[)]")
            for (value <- ballotToList) {
            val split = value.replaceFirst("[(]","").split(":")
            val candidate = split(0)
            val numAndDen = split(1).split("/")

            candidatesList.+=:((Candidate(candidate), Rational(numAndDen(0).toInt, numAndDen(1).toInt)))
            }
            candidatesList.toList
        }

        def parseScoreBallots(ballots: List[Ballot]): List[agora.model.ScoreBallot] = {
            var scoreBallots = ListBuffer[agora.model.ScoreBallot]()
            var id = 1
            for (ballot <- ballots) {
            scoreBallots += ScoreBallot(parseScoreBallot(ballot), id, Rational(1, 1))
            id = id + 1
            }
            scoreBallots.toList
        }

        Then we used it as follows

        case "RangeVoting" => {
          val election = Election(parseScoreBallots(ballots))
          RangeVoting.winners(election, candidates, noVacancies)
        }
    ```
2. Then define a case statement in the services.Countvotes.countvotesMethod method to handle the new algorithm. Example code.

    ```
        case "new algorithm name" => {
            val election = Election(parseNewBallotType(ballots))
            new_algorithm_name.winners(election, candidates, noVacancies)
        }
    ```

# API Documentation
 We used [Swagger-play](https://github.com/swagger-api/swagger-play) as our API documentation library. It is a utility that is used to produce swagger API style documentation using. 
 * To define a controller as one that contains API documentation you do the following using Swagger-play
    ```
        @Api(value = "Election")
        class ElectionController @Inject()(...)(implicit ex: ExecutionContext)
                                            extends AbstractController(components) with I18nSupport
                                        {
                                        .
                                        .
                                        .
                                        }
                                        
    ```
 * To define parameters required for an endpoint we do the following 
    ```
        @ApiOperation(value = "Creates a new election for the user", response = classOf[ResponseMessage])
        @ApiImplicitParams(
            Array(
                new ApiImplicitParam(
                    name = "X-Auth-Token",
                    value = "User access token",
                    required = true,
                    dataType = "string",
                    paramType = "header"
                ),
                new ApiImplicitParam(
                    value = "Election data",
                    required = true,
                    dataType = "formatters.json.ElectionData",
                    paramType = "body"
                )
            )
        )
        def createElection() = silhouette.SecuredAction.async(parse.json) { implicit request => ...}
    ```
 * To define a model as an API model we do the following
    ```
        @ApiModel(description = "Data required to create an election", value = "ElectionData")
        case class ElectionData(
            @ApiModelProperty(value = "Election name", required = true)name: String,
            @ApiModelProperty(value = "Election description", required = true)description: String,
            @ApiModelProperty(value = "Election candidates", required = true)candidates: List[String],
            @ApiModelProperty(value = "Election ballot visibility status", required = true)ballotVisibility: String,
            @ApiModelProperty(value = "Voters list should be made visible?", required = true)voterListVisibility:  Boolean,
            @ApiModelProperty(value = "Election start date", required = true)startingDate: DateTime,
            @ApiModelProperty(value = "Election end date", required = true)endingDate: DateTime,
            @ApiModelProperty(value = "Invite voters?", required = true)isInvite: Boolean,
            @ApiModelProperty(value = "Get real time result?", required = true)isRealTime: Boolean,
            @ApiModelProperty(value = "Voting algorithm", required = true)votingAlgo: String,
            @ApiModelProperty(value = "Number of vacancies", required = true)noVacancies : Int )

    ```

# Demo
Do you want to see it in action? Here is a working version deployed to heroku

1. Development Version : http://agora-rest-api.herokuapp.com/

# Frontend
Do you want to see it in action? Here is a working version deployed to heroku
1. Development Version : https://agora-fontend.herokuapp.com/
2. Wiki:  https://gitlab.com/icemc/Agora-web-frontend/blob/master/docs/wiki.md